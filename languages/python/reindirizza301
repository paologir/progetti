#!/usr/bin/env python3
import sys
import argparse
import re
import os
from datetime import datetime

try:
    import pyperclip
except ImportError:
    pyperclip = None

def backup_filename(original):
    """Genera un nome file per il backup con timestamp"""
    timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
    return f"{original}_backup_{timestamp}"

def validate_url(url):
    """Validazione base degli URL"""
    pattern = re.compile(
        r'^(?:http|ftp)s?://'  # http:// o https://
        r'(?:(?:[A-Z0-9](?:[A-Z0-9-]{0,61}[A-Z0-9])?\.)+(?:[A-Z]{2,6}\.?|[A-Z0-9-]{2,}\.?)|'  # dominio
        r'localhost|'  # localhost
        r'\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3})'  # o indirizzo IP
        r'(?::\d+)?'  # porta opzionale
        r'(?:/?|[/?]\S+)$', re.IGNORECASE)
    return re.match(pattern, url) is not None

def parse_line(line):
    """Analizza una linea estraendo gli URL usando diversi separatori"""
    separators = ['\t', ':', ';', '|']
    for sep in separators:
        if sep in line:
            parts = line.split(sep, 1)
            if len(parts) == 2:
                return [part.strip() for part in parts]
    return None

def generate_rules(sources):
    """Genera le regole di redirect dagli URL sorgente"""
    rules = []
    for source, dest in sources:
        if not validate_url(source) or not validate_url(dest):
            print(f"Avviso: Coppia di URL non valida ignorata - {source} → {dest}")
            continue
        
        # Formattazione corretta per .htaccess
        source = source.rstrip('/').replace('https://', '').replace('http://', '')
        dest = dest.rstrip('/')
        
        rules.append(f"Redirect 301 /{source.lstrip('/')} {dest}")
    return rules

def main():
    parser = argparse.ArgumentParser(description='Generatore regole 301 redirect per .htaccess')
    parser.add_argument('-s', '--single', nargs=2, metavar=('SOURCE', 'DEST'), help='Reindirizzamento singolo')
    parser.add_argument('-f', '--file', metavar='FILE', help='File di input con gli URL')
    parser.add_argument('-o', '--output', metavar='FILE', default='.htaccess', help='File di output (default: .htaccess)')
    parser.add_argument('-c', '--clipboard', action='store_true', help='Copia negli appunti')
    
    args = parser.parse_args()
    sources = []

    # Gestione input
    if args.single:
        sources.append(args.single)
    elif args.file:
        if not os.path.exists(args.file):
            print(f"Errore: File {args.file} non trovato!")
            sys.exit(1)
        with open(args.file, 'r') as f:
            for line in f:
                line = line.strip()
                if line and not line.startswith('#'):
                    parts = parse_line(line)
                    if parts and len(parts) == 2:
                        sources.append(parts)
                    else:
                        print(f"Avviso: Linea malformata ignorata: {line}")
    elif not sys.stdin.isatty():
        for line in sys.stdin:
            line = line.strip()
            if line:
                parts = parse_line(line)
                if parts and len(parts) == 2:
                    sources.append(parts)
                else:
                    print(f"Avviso: Linea malformata ignorata: {line}")
    else:
        parser.print_help()
        sys.exit(1)

    # Generazione regole
    rules = generate_rules(sources)
    
    if not rules:
        print("Nessuna regola valida generata.")
        sys.exit(0)
    
    output_text = '\n'.join(rules)
    
    # Gestione backup se il file esiste già
    if os.path.exists(args.output):
        backup = backup_filename(args.output)
        try:
            os.rename(args.output, backup)
            print(f"⚠ File esistente rinominato in: {backup}")
        except Exception as e:
            print(f"Errore durante il backup: {str(e)}")
            sys.exit(1)
    
    # Output a video
    print("\nRegole generate:\n")
    print(output_text)
    
    # Copia negli appunti
    if args.clipboard:
        if pyperclip:
            pyperclip.copy(output_text)
            print("\n✓ Testo copiato negli appunti")
        else:
            print("\n⚠ Impossibile copiare negli appunti: pyperclip non installato")
    
    # Salvataggio su file
    with open(args.output, 'w') as f:
        f.write(output_text)
    print(f"\n✓ Regole salvate in {args.output}")

if __name__ == "__main__":
    main()
